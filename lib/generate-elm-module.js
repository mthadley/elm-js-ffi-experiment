/**
 * The Elm type that wraps the underlying JS proxy, and is therefore
 * required to be passed to any foreign function calls.
 */
const API_TYPE = "Api";

/**
 * Convert an elm-ffi type to it's associated Elm type.
 */
function toElmType(type) {
  switch (type) {
    case "float":
      return "Float";
    case "int":
      return "Int";
    case "string":
      return "String";
    default:
      throw new TypeError(`"${type}" is not a valid type.`);
  }
}

/**
 * Convert an elm-ffi type to a decoder for the equivalent type in Elm.
 */
function toElmDecoder(type) {
  switch (type) {
    case "float":
      return "Decode.float";
    case "int":
      return "Decode.int";
    case "string":
      return "Decode.string";
    default:
      throw new TypeError(`"${type}" is not a valid type.`);
  }
}

/**
 * Get the function in Elm that would convert this elm-ffi type into
 * a string.
 */
function toElmToStringFn(type) {
  switch (type) {
    case "float":
      return "String.fromFloat";
    case "int":
      return "String.fromInt";
    case "string":
      return "identity";
    default:
      throw new TypeError(`"${type}" is not a valid type.`);
  }
}

/**
 * Generate an Elm function given the api and function spec.
 */
function generateFunction(spec, name, fnSpec) {
  const fnSignature = [
    API_TYPE,
    ...fnSpec.parameters.map(toElmType),
    `Result ElmFfi.Error ${toElmType(fnSpec.returns)}`
  ].join(" -> ");

  let fnParams = Array.from(
    { length: fnSpec.parameters.length },
    (_, i) => `a${i}`
  ).join(" ");

  if (fnParams) fnParams += " ";

  let callParams = [
    `"${name}"`,
    ...fnSpec.parameters.map((pType, i) => `${toElmToStringFn(pType)} a${i}`)
  ].join(", ");

  if (callParams) callParams = ` ${callParams} `;

  return `{-| -}
${name} : ${fnSignature}
${name} api ${fnParams}=
    call api ${toElmDecoder(fnSpec.returns)} [${callParams}]
`;
}

/**
 * Generate an Elm module that exposes functions and types for calling
 * into the foreign Api.
 */
function generateElmModule(spec) {
  const fnNames = Object.keys(spec.functions);

  return `module ${spec.moduleName} exposing
    ( ${API_TYPE}, decode
    , ${fnNames.join(", ")}
    )

{-| This module was generated by elm-ffi. DO NOT EDIT BY HAND!

@docs ${API_TYPE}, decode
@docs ${fnNames.join(", ")}

-}

import ElmFfi
import Json.Decode as Decode exposing (Decoder)


{-| -}
type ${API_TYPE}
    = ${API_TYPE} Decode.Value


{-| -}
decode : Decoder Api
decode =
    Decode.value
        |> Decode.andThen
            (\\value ->
                case Decode.decodeValue (Decode.field "__api" Decode.string) value of
                    Ok apiName ->
                        if apiName == "${spec.moduleName}" then
                            Decode.succeed (Api value)

                        else
                            Decode.fail ("Expecting the Api for ${
                              spec.moduleName
                            } but got one for " ++ apiName)

                    Err err ->
                        Decode.fail ("Failed to decode Api for ${
                          spec.moduleName
                        }: " ++ Decode.errorToString err)
            )


${Object.entries(spec.functions)
  .map(([name, fnSpec]) => generateFunction(spec, name, fnSpec))
  .join("\n\n")}


call : Api -> Decoder a -> List String -> Result ElmFfi.Error a
call (Api proxy) decoder fullPath =
    let
        decodeNext path value =
            case path of
                [] ->
                    Decode.decodeValue
                        (Decode.oneOf
                            [ Decode.field "value" decoder
                                |> Decode.map Ok
                            , Decode.field "error" Decode.string
                                |> Decode.map (Err << ElmFfi.FunctionCallError)
                            ]
                        )
                        value
                        |> Result.mapError ElmFfi.JsonDecodeError
                        |> Result.andThen identity

                field :: rest ->
                    Decode.decodeValue (Decode.field field Decode.value) value
                        |> Result.mapError ElmFfi.JsonDecodeError
                        |> Result.andThen (decodeNext rest)
    in
    decodeNext fullPath proxy
`;
}

module.exports = { generateElmModule };
